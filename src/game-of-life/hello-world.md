# Hello, World!

이 절에서는 "Hello, World!"라고 경고창을 띄우는 웹 페이지를 만들 것입니다. 이는 Rust 및 WebAssembly 프로그램을 빌드하고 실행하는 방법을 보여줄 것입니다.
<!-- This section will show you how to build and run your first Rust and WebAssembly
program: a Web page that alerts "Hello, World!" -->

시작하기 전에 [개발환경을 구축](setup.html)했는지 확인하십시오.
<!-- Make sure you have followed the [setup instructions](setup.html) before beginning. -->

<!-- ## Clone the Project Template -->
## 프로젝트 템플릿 복제

프로젝트 템플릿은 미리 기본값이 설정되어 있습니다. 이를 통해 웹용 코드를 빠르게 빌드, 통합 및 패키지할 수 있습니다.

다음 명령을 사용하여 프로젝트 템플릿을 복제합니다.

<!-- The project template comes pre-configured with sane defaults, so you can quickly
build, integrate, and package your code for the Web.

Clone the project template with this command: -->

```text
cargo generate --git https://github.com/rustwasm/wasm-pack-template
```

새 프로젝트 이름을 입력하라는 메시지가 표시됩니다. 우리는 "**wasm-game-of-life**"를 사용할 것입니다
<!-- This should prompt you for the new project's name. We will use -->
<!-- **"wasm-game-of-life"**. -->

```text
wasm-game-of-life
```

<!-- ## What's Inside -->
## 무엇이 안에 들어있다요?

새로운 `wasm-game-of-life` 프로젝트 안으로 들어갑시다.
<!-- Enter the new `wasm-game-of-life` project -->

```
cd wasm-game-of-life
```

내용을 살펴보겠습니다.
<!-- and let's take a look at its contents: -->

```text
wasm-game-of-life/
├── Cargo.toml
├── LICENSE_APACHE
├── LICENSE_MIT
├── README.md
└── src
    ├── lib.rs
    └── utils.rs
```
이 파일 중 몇 가지를 자세히 살펴보겠습니다.
<!-- Let's take a look at a couple of these files in detail. -->

### `wasm-game-of-life/Cargo.toml`

`Cargo.toml` 파일은 Rust의 패키지 관리자이자 빌드 도구인 `cargo`에 대한 종속성과 메타데이터를 지정합니다. 
이것은 `.wasm` 라이브러리 생성을 위해 `wasm-bindgen` 종속성, 나중에 파헤칠 몇 가지 선택적 종속성, 초기화된 `crate-type` 등으로 미리 구성되어 제공됩니다.

<!-- The `Cargo.toml` file specifies dependencies and metadata for `cargo`, Rust's
package manager and build tool. This one comes pre-configured with a
`wasm-bindgen` dependency, a few optional dependencies we will dig into later,
and the `crate-type` properly initialized for generating `.wasm` libraries. -->

### `wasm-game-of-life/src/lib.rs`

`src/lib.rs` 파일은 WebAssembly로 컴파일하는 Rust 크레이트의 루트입니다. JavaScript와 연계하기 위해 `wasm-bindgen`을 사용합니다. `window.alert` JavaScript 함수를 가져오고 인사말 메시지를 경고하는 `greet` Rust 함수를 내보냅니다.

<!-- The `src/lib.rs` file is the root of the Rust crate that we are compiling to
WebAssembly. It uses `wasm-bindgen` to interface with JavaScript. It imports the
`window.alert` JavaScript function, and exports the `greet` Rust function, which
alerts a greeting message. -->

```rust
mod utils;

use wasm_bindgen::prelude::*;

// When the `wee_alloc` feature is enabled, use `wee_alloc` as the global
// allocator.
#[cfg(feature = "wee_alloc")]
#[global_allocator]
static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;

#[wasm_bindgen]
extern {
    fn alert(s: &str);
}

#[wasm_bindgen]
pub fn greet() {
    alert("Hello, wasm-game-of-life!");
}
```

### `wasm-game-of-life/src/utils.rs`

`src/utils.rs` 모듈은 WebAssembly로 컴파일된 Rust로 작업하기 쉽게 해주는 공통 유틸리티를 제공합니다. [wasm 코드 디버깅](debugging.html)을 볼 때와 같이 튜토리얼의 뒷부분에서 이러한 유틸리티 중 일부를 더 자세히 살펴보겠지만 지금은 이 파일을 무시하겠습니다.

<!-- The `src/utils.rs` module provides common utilities to make working with Rust
compiled to WebAssembly easier. We will take a look at some of these utilities
in more detail later in the tutorial, such as when we look at [debugging our wasm
code](debugging.html), but we can ignore this file for now. -->

## Build the Project

우리는 `wasm-pack`을 사용하여 다음 빌드 단계를 조정할 것입니다.
<!-- We use `wasm-pack` to orchestrate the following build steps: -->

* Rust 1.30 이상과 `rustup`을 통해 설치된 `wasm32-unknown-unknown` target이 있는지 확인하십시오.
* Rust 소스를 `cargo`를 통해 WebAssembly `.wasm` 바이너리로 컴파일합니다.
* Rust에서 생성한 WebAssembly를 사용하기 위한 JavaScript API를 생성하려면 `wasm-bindgen`을 사용하세요.

<!-- * Ensure that we have Rust 1.30 or newer and the `wasm32-unknown-unknown`
  target installed via `rustup`,
* Compile our Rust sources into a WebAssembly `.wasm` binary via `cargo`,
* Use `wasm-bindgen` to generate the JavaScript API for using our Rust-generated
  WebAssembly. -->

이 모든 작업을 수행하려면 프로젝트 디렉터리 내에서 다음 명령을 실행합니다.
<!-- To do all of that, run this command inside the project directory: -->

```
wasm-pack build
```

빌드가 완료되면 `pkg` 디렉토리에서 artifacts를 찾을 수 있습니다. 이는 다음 내용을 포함해야 합니다.
<!-- When the build has completed, we can find its artifacts in the `pkg` directory,
and it should have these contents: -->

```
pkg/
├── package.json
├── README.md
├── wasm_game_of_life_bg.wasm
├── wasm_game_of_life.d.ts
└── wasm_game_of_life.js
```

'README.md' 파일은 메인 프로젝트에서 복사했지만 나머지는 완전히 새 파일입니다.
<!-- The `README.md` file is copied from the main project, but the others are
completely new. -->

### `wasm-game-of-life/pkg/wasm_game_of_life_bg.wasm`

`.wasm` 파일은 우리의 Rust 소스에서 Rust 컴파일러에 의해 생성된 WebAssembly binary입니다. 여기에는 모든 Rust 함수와 데이터의 컴파일된 버전이 포함되어 있습니다. 예를 들어, 내보낸 "greet" 함수가 있습니다.

<!-- The `.wasm` file is the WebAssembly binary that is generated by the Rust
compiler from our Rust sources. It contains the compiled-to-wasm versions of all
of our Rust functions and data. For example, it has an exported "greet"
function. -->

### `wasm-game-of-life/pkg/wasm_game_of_life.js`

`.js` 파일은 `wasm-bindgen`에 의해 생성되며 DOM 객체와 JavaScript 함수을 Rust로 가져오고 WebAssembly 기능에 대한 멋진 API를 JavaScript에 노출하기 위한 JavaScript glue를 포함합니다. 예를 들어 WebAssembly 모듈에서 내보낸 `greet` 함수를 래핑하는 JavaScript `greet` 함수가 있습니다. 지금 당장은 이 glue가 별로 도움이 되지 않지만, wasm과 JavaScript 간에 더 흥미로운 값을 주고받기 시작하면 경계를 넘어 해당 값을 관리하는 데 도움이 될 것입니다.

<!-- The `.js` file is generated by `wasm-bindgen` and contains JavaScript glue for
importing DOM and JavaScript functions into Rust and exposing a nice API to the
WebAssembly functions to JavaScript. For example, there is a JavaScript `greet`
function that wraps the `greet` function exported from the WebAssembly
module. Right now, this glue isn't doing much, but when we start passing more
interesting values back and forth between wasm and JavaScript, it will help
shepherd those values across the boundary. -->

```js
import * as wasm from './wasm_game_of_life_bg';

// ...

export function greet() {
    return wasm.greet();
}
```

### `wasm-game-of-life/pkg/wasm_game_of_life.d.ts`

`.d.ts` 파일에는 JavaScript glue에 대한 [TypeScript][] 타입 선언이 포함되어 있습니다. TypeScript를 사용하는 경우 WebAssembly 함수에 대한 호출 타입을 확인할 수 있으며 IDE에서 자동 완성 및 제안을 사용할 수 있습니다! TypeScript를 사용하지 않는 경우 이 파일을 무시해도 됩니다.

<!-- The `.d.ts` file contains [TypeScript][] type declarations for the JavaScript
glue. If you are using TypeScript, you can have your calls into WebAssembly
functions type checked, and your IDE can provide autocompletions and
suggestions! If you aren't using TypeScript, you can safely ignore this file. -->

```typescript
export function greet(): void;
```

[TypeScript]: http://www.typescriptlang.org/

### `wasm-game-of-life/pkg/package.json`

[`package.json`][package.json] 파일에는 생성된 JavaScript 및 WebAssembly 패키지에 대한 메타데이터가 포함되어 있습니다. 이것은 npm 및 JavaScript 번들러에서 패키지, 패키지 이름, 버전 및 기타 여러 항목 간의 종속성을 결정하는 데 사용됩니다. JavaScript 도구와 통합하는 데 도움이 되며 패키지를 npm에 게시할 수 있습니다.

<!-- [The `package.json` file contains metadata about the generated JavaScript and
WebAssembly package.][package.json] This is used by npm and JavaScript bundlers
to determine dependencies across packages, package names, versions, and a bunch
of other stuff. It helps us integrate with JavaScript tooling and allows us to
publish our package to npm. -->

```json
{
  "name": "wasm-game-of-life",
  "collaborators": [
    "Your Name <your.email@example.com>"
  ],
  "description": null,
  "version": "0.1.0",
  "license": null,
  "repository": null,
  "files": [
    "wasm_game_of_life_bg.wasm",
    "wasm_game_of_life.d.ts"
  ],
  "main": "wasm_game_of_life.js",
  "types": "wasm_game_of_life.d.ts"
}
```

[package.json]: https://docs.npmjs.com/files/package.json

## 웹 페이지에 넣기
<!-- ## Putting it into a Web Page -->

우리의 `wasm-game-of-life` 패키지를 웹 페이지에서 사용하기 위해 [`create-wasm-app`][create-wasm-app] JavaScript 프로젝트 템플릿을 사용할 것입니다.
<!-- To take our `wasm-game-of-life` package and use it in a Web page, we use [the
`create-wasm-app` JavaScript project template][create-wasm-app]. -->

[create-wasm-app]: https://github.com/rustwasm/create-wasm-app

`wasm-game-of-life` 디렉토리 내에서 다음 명령어 실행하십시오:
<!-- Run this command within the `wasm-game-of-life` directory: -->

```
npm init wasm-app www
```

다음은 새로운 `wasm-game-of-life/www` 하위 디렉토리에 포함된 파일 트리입니다.
<!-- Here's what our new `wasm-game-of-life/www` subdirectory contains: -->

```
wasm-game-of-life/www/
├── bootstrap.js
├── index.html
├── index.js
├── LICENSE-APACHE
├── LICENSE-MIT
├── package.json
├── README.md
└── webpack.config.js
```

다시 한 번 더, 이 파일 중 일부를 자세히 살펴보겠습니다.
<!-- Once again, let's take a closer look at some of these files. -->

### `wasm-game-of-life/www/package.json`

이 `package.json`은  `webpack`와 `webpack-dev-server`로 미리 설정된
종속성 뿐만 아니라, `hello-wasm-pack`의 종속성을 포합합니다. 여기에는  `wasm-pack-template` 패키지가 npm에 게시된 버전을 포함합니다.
<!-- This `package.json` comes pre-configured with `webpack` and `webpack-dev-server`
dependencies, as well as a dependency on `hello-wasm-pack`, which is a version
of the initial `wasm-pack-template` package that has been published to npm. -->

### `wasm-game-of-life/www/webpack.config.js`

이 파일은 웹 팩과 해당 로컬 개발 서버를 구성합니다. 미리 구성된 상태로 제공되며 웹 팩과 로컬 개발 서버가 작동하도록 하기 위해 이 기능을 조정할 필요가 없습니다.
<!-- This file configures webpack and its local development server. It comes
pre-configured, and you shouldn't have to tweak this at all to get webpack and
its local development server working. -->

### `wasm-game-of-life/www/index.html`

이것은 웹 페이지의 루트 HTML 파일입니다. 그것은 `index.js`를 랩핑한 `bootstrap.js` 파일을 로드하는 것 외에 많은 작업을 하지 않습니다.
<!-- This is the root HTML file for the Web page. It doesn't do much other than
load `bootstrap.js`, which is a very thin wrapper around `index.js`. -->

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Hello wasm-pack!</title>
  </head>
  <body>
    <script src="./bootstrap.js"></script>
  </body>
</html>
```

### `wasm-game-of-life/www/index.js`

`index.js`는 웹 페이지의 JavaScript를 실행시킵니다. 이는 기본 `wasm-pack-template`의 컴파일된 WebAssembly 및 JavaScript glue가 포함된 `hello-wasm-pack` npm 패키지를 가져온 다음 `hello-wasm-pack`의 `greet` 기능을 호출합니다.

<!-- The `index.js` is the main entry point for our Web page's JavaScript. It imports
the `hello-wasm-pack` npm package, which contains the default
`wasm-pack-template`'s compiled WebAssembly and JavaScript glue, then it calls
`hello-wasm-pack`'s `greet` function. -->

```js
import * as wasm from "hello-wasm-pack";

wasm.greet();
```

<!-- ### Install the dependencies -->
### 종속성 설치

먼저 `wasm-game-of-life/www` 하위 디렉토리에서 `npm install`을 실행하여 로컬 개발 서버와 종속 항목이 설치되었는지 확인합니다.
<!-- First, ensure that the local development server and its dependencies are
installed by running `npm install` within the `wasm-game-of-life/www`
subdirectory: -->

```text
npm install
```

이 명령은 한 번만 실행하면 되며 `webpack` JavaScript 번들러와 개발 서버를 설치합니다.
<!-- This command only needs to be run once, and will install the `webpack`
JavaScript bundler and its development server. -->

> 메모: 'webpack'은 Rust 및 WebAssembly 작업에 필요하지 않으며 여기서는 편의를 위해 선택한 번들러 및 개발 서버일 뿐입니다. Parcel 및 Rollup은 WebAssembly를 ECMAScript 모듈로 가져오기도 지원해야 합니다. 원한다면 [번들러 없이][] Rust와 WebAssembly를 사용할 수도 있습니다!
<!-- > Note that `webpack` is not required for working with Rust and WebAssembly, it
> is just the bundler and development server we've chosen for convenience
> here. Parcel and Rollup should also support importing WebAssembly as
> ECMAScript modules. You can also use Rust and WebAssembly [without a
> bundler][] if you prefer! -->

[번들러 없이]: https://rustwasm.github.io/docs/wasm-bindgen/examples/without-a-bundler.html

### `www`의 로컬 패키지  `wasm-game-of-life`  사용하기
<!-- ### Using our Local `wasm-game-of-life` Package in `www` -->

npm의 `hello-wasm-pack` 패키지를 사용하는 대신 로컬 `wasm-game-of-life` 패키지를 사용하고 싶습니다. 이를 통해 Game of Life 프로그램을 점진적으로 개발할 수 있습니다.

<!-- Rather than use the `hello-wasm-pack` package from npm, we want to use our local
`wasm-game-of-life` package instead. This will allow us to incrementally develop
our Game of Life program. -->

`"devDependencies"` 다음에 있는 `wasm-game-of-life/www/package.json` 파일을 연 뒤,  `"dependencies"` 속성에 `"file :../pkg"`:`"wasm-game-of-life"` 속성을 추가하십시오.

<!-- Open up `wasm-game-of-life/www/package.json` and next to `"devDependencies"`, add the `"dependencies"` field,
including a `"wasm-game-of-life": "file:../pkg"` entry: -->

```js
{
  // ...
  "dependencies": {                     // Add this three lines block!
    "wasm-game-of-life": "file:../pkg"
  },
  "devDependencies": {
    //...
  }
}
```

다음으로 `hello-wasm-pack` 패키지 대신 `wasm-game-of-life`를 가져오도록 `wasm-game-of-life/www/index.js`를 수정합니다.
<!-- Next, modify `wasm-game-of-life/www/index.js` to import `wasm-game-of-life`
instead of the `hello-wasm-pack` package: -->

```js
import * as wasm from "wasm-game-of-life";

wasm.greet();
```

새로운 종속성을 선언했으므로 설치해야 합니다.
<!-- Since we declared a new dependency, we need to install it: -->
```text
npm install
```

이제 웹 페이지를 로컬에서 접속할 준비가 되었습니다!
<!-- Our Web page is now ready to be served locally! -->

<!-- ## Serving Locally -->
## 로컬에서 접속하기

다음으로 개발 서버용 터미널을  `wasm-game-of-life/www` 디렉토리에서 새로 열어 서버를 실행합니다. 이는 백그라운드에서 계속 실행되도록 하기 위함입니다. 이러면 다른 명령을 실행하는 것을 차단하지 않습니다.

<!-- Next, open a new terminal for the development server. Running the server in a
new terminal lets us leave it running in the background, and doesn't block us
from running other commands in the meantime. In the new terminal, run this
command from within the `wasm-game-of-life/www` directory: -->

```
npm run start
```

웹 브라우저에서 [http://localhost:8080/](http://localhost:8080/)으로 이동합니다.
경고 메시지가 표시되어야 합니다.

[![Screenshot of the "Hello, wasm-game-of-life!" Web page alert](../images/game-of-life/hello-world.png)](../images/game-of-life/hello-world.png)

변경 사항을 반영하고 싶으면 [http://localhost:8080/](http://localhost:8080/), `wasm-game-of-life` 디렉토리에서 `wasm-pack build` 명령을 다시 실행하십시오.

<!-- Anytime you make changes and want them reflected on
[http://localhost:8080/](http://localhost:8080/), just re-run the `wasm-pack
build` command within the `wasm-game-of-life` directory. -->

## 연습문제

* `wasm-game-of-life/src/lib.rs`의 `greet` 함수에 `name: &str` 매개변수를 추가하여 경고 메시지를 `wasm-game-of-life/www/index.js` 안에 있는 `greet` 함수에 이름을 전달하도록 합시다. `wasm-pack build`로 `.wasm` 바이너리를 다시 빌드한 다음 웹 브라우저에서 [http://localhost:8080/](http://localhost:8080/)을 새로 고침하면 사용자 정의 인사말이 표시될 것입다!

<!-- * Modify the `greet` function in `wasm-game-of-life/src/lib.rs` to take a `name:
  &str` parameter that customizes the alerted message, and pass your name to the
  `greet` function from inside `wasm-game-of-life/www/index.js`. Rebuild the
  `.wasm` binary with `wasm-pack build`, then refresh
  [http://localhost:8080/](http://localhost:8080/) in your Web browser and you
  should see a customized greeting! -->

  <details>
    <summary>정답</summary>

  `greet` 함수의 새 버전이  `wasm-game-of-life/src/lib.rs`에 있습니다:

  ```rust
  #[wasm_bindgen]
  pub fn greet(name: &str) {
      alert(&format!("Hello, {}!", name));
  }
  ```

  `wasm-game-of-life/www/index.js` 안에 있는 `greet` 함수의 새로운 호출 :
  <!-- New invocation of `greet` in `wasm-game-of-life/www/index.js`: -->

  ```js
  wasm.greet("Your Name");
  ```

  </details>
